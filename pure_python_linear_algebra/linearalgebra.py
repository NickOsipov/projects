# Модуль linearalgebra
# Данный модуль предназначен для работы с элементами линейной алгебры.
# Модуль разработан с помощью стандартной библиотеки Python.
# 
# Для использования модуля linearalgebra примем 
# следующее соглашение о записи векторов и матриц.
#
# Вектор-строка записывается во вложенный список вида:
# vector_row = [[x_11, x_12, ..., x_1N]]
# где x - элемент вектора, 
# первый индекс - индекс элемента по номеру строки, 
#     равен 1, так как вектор содержит одну строку;
# второй индекс - индекс элемента по номеру столбца, 
#     последний элемент с индексом N, соответсвует числу столбцов(элементов вектора-строки).
#
# Вектор-столбец записывается во вложенный список вида:
# vector_col = [[x_11],
#               [x_21],
#               ...,
#               [x_M1]]
# где x - элемент вектора-столбца; 
# первый индекс - индекс элемента по номеру строки, 
#     последний элемент с индексом M, соответсвует числу строк(элементов вектора-столбца);
# второй индекс - индекс элемента по номеру столбца, 
#     равен 1, так как вектор содержит один столбец.
#
# Матрица записывается в виде многомерного списка M-строк на N-столбцов:
# matrix = [[x_11, x_12, ..., x_1N],
#           [x_21, x_22, ..., x_1N]
#           ......................,
#           [x_M1, x_M2, ..., x_MN]]
# где x - элемент матрицы;
# первый индекс - индекс элемента по номеру строки, последний элемент с индексом M, соответсвует числу строк;
# второй индекс - индекс элемента по номеру столбца, последний элемент с индексом N, соответсвует числу столбцов.


# 01. функция сложения матриц

def addition(A, B):
    """Функция сложения матриц.
    A : матрица или вектор
    B : матрица, вектор или число(скаляр)
    """
    
    # Поэлементное сложение матрицы или вектора с числом
    if isinstance(B, (int, float)):
        scaler = B        
        result = [[A[row][col] + scaler for col in range(len(A[0]))] 
                  for row in range(len(A))]
        return result

    # Сложение матриц выполнятеся поэлементно, поэтому необходимо
    # выполнить проверку на соответствие размеров матриц
    rows_A = len(A)    # количество строк первой матрицы
    cols_A = len(A[0]) # количество столбцов первой матрицы
    rows_B = len(B)    # количество строк второй матрицы
    cols_B = len(B[0]) # количество столбцов второй матрицы
    
    if rows_A == rows_B and cols_A == cols_B:
        result = [[A[row][col] + B[row][col] for col in range(cols_A)] 
                  for row in range(rows_A)]
        return result
    else:
        print("Невозможно сложить объекты. Разная размерность.")
        return


# 02. Функция вычитания матриц

def subtraction(A, B):
    """Функция вычитания матриц.
    A, B : матрицы поступающие на вход.
    """
    # Поэлементное вычитание матрицы или вектора с числом
    if isinstance(B, (int, float)):
        scaler = B        
        result = [[A[row][col] - scaler for col in range(len(A[0]))] 
                  for row in range(len(A))]
        return result
    
    # Вычитание матриц выполнятеся поэлементно, поэтому необходимо
    # выполнить проверку на соответствие размеров матриц
    rows_A = len(A)    # количество строк первой матрицы
    cols_A = len(A[0]) # количество столбцов первой матрицы
    rows_B = len(B)    # количество строк второй матрицы
    cols_B = len(B[0]) # количество столбцов второй матрицы
    
    if rows_A == rows_B and cols_A == cols_B:
        result = [[A[row][col] - B[row][col] for col in range(cols_A)] 
                  for row in range(rows_A)]
        return result
    else:
        print("Невозможно вычесть объекты. Разная размерность.")
        return


# 03. Функция умножения матриц

def multiply(A, B):
    """Функция умножения матриц.
    A : матрица поступающая на вход
    B : матрица либо число
    """
    # Если нам необходимо умножение матрицы либо вектора на число
    # умножение производится поэлементно
    if isinstance(B, (int, float)):
        scaler = B        
        result = [[A[row][col] * scaler for col in range(len(A[0]))] 
                  for row in range(len(A))]
        return result
    else:
        # Если мы производим перемножение матриц:
        # Количество столбцов первой матрицы должно быть равно 
        # количеству строк второй матрицы
        rows_A = len(A)    # количество строк первой матрицы
        cols_A = len(A[0]) # количество столбцов первой матрицы
        rows_B = len(B)    # количество строк второй матрицы
        cols_B = len(B[0]) # количество столбцов второй матрицы
        
        if cols_A == rows_B:
            tmp = []
            result = []
            for row in range(rows_A):
                for col in range(cols_B):
                    summ = 0
                    for k in range(rows_B):
                        summ = summ + (A[row][k] * B[k][col])
                    tmp.append(summ)
                result.append(tmp)
                tmp = []
            return result
        else:
            print("Невозможно перемножить объекты. Разная размерность.")
            return


# 04. Транспонирование матриц

def transpose(A):
    """Функция для нахождения транспонированной матрицы.
    A : матрица, либо вектор
    """
    result = list(map(list, zip(*A)))
    return result

# 05. Минор матрицы

def get_minor(A, row, col):
    """Функция для нахождения минора матрицы.
    A : матрица
    row : индекс по строке
    col : индекс по столбцу
    """
    result = [rows[:col] + rows[col+1:] for rows in (A[:row] + A[row+1:])]
    return result

# 06. Определитель матрицы

def get_determinant(A):
    """Функция для нахождения определителя матрицы.
    A : матрица
    """

    # Если матрица имеет размер 2x2:
    if len(A) == 2 and len(A[0]) == 2:
        determinant = A[0][0] * A[1][1] - A[0][1] * A[1][0]
        return determinant

    if len(A) == len(A[0]):
        determinant = 0
        for i in range(len(A)):
            determinant += ((-1) ** i) * A[0][i] * get_determinant(get_minor(A, 0, i))
        return determinant
    else:
        print("Для неквадратной матрицы невозможно найти определитель")
        return


# 07. Проверка матрицы на квадратность.

def is_square(A):
    """Функция для проверки матрицы на квадратность"""
    return len(A) == len(A[0])


# 08. Проверка матрицы на вырожденность.

def is_singular(A):
    """Функция для проверки матрицы на вырожденность"""
    return get_determinant(A) == 0


# 09. Обратная матрица

def inverse(A):
    """Функция для нахождения обратной матрицы.
    A : матрица
    """
    # Необходимо провести проверку является ли матрица квадратной
    rows_A = len(A)    # количество строк матрицы
    cols_A = len(A[0]) # количество столбцов матрицы
    
    if not is_square(A):
        print("Матрица не является квадратной.",
              "Обратную матрицу можно найти только для квадратной матрицы",
              sep="\n")
        return

    # Необходимо провести проверку является ли матрица вырожденной
    determinant = get_determinant(A)
    if is_singular(A):
        print("Определитель матрицы равен 0.",
              "Матрица является вырожденной.",
              "Обратную матрицу можно найти только для невырожденной квадратной матрицы",
              sep="\n")
        return

    # Если размер матрицы 2x2:
    if rows_A == 2 and cols_A == 2:
        result = [[A[1][1] / determinant, -1 * A[0][1] / determinant],
                  [-1 * A[1][0] / determinant, A[0][0] / determinant]]
        return result

    # Найдем транспонированную матрицу алгебраических дополнений
    cofactors = []
    for row in range(rows_A):
        cofactor_row = []
        for col in range(cols_A):
            minor = get_minor(A, row, col)
            cofactor_row.append(((-1) ** (row + col)) * get_determinant(minor))
        cofactors.append(cofactor_row)
    cofactors = transpose(cofactors)
    for row in range(len(cofactors)):
        for col in range(len(cofactors)):
            cofactors[row][col] = cofactors[row][col] / determinant
    return cofactors


# 10. Деление матриц

def divide(A, B, elements=False):
    """Функция деления матриц.
    Метод реализован по правилам линейной алгебры.
    Если необходим метод поэлементного деления соответственно стоящих элементов двух матриц, 
    используйте аргумент elements со значением True. (аналог метода divide в numpy)
    A : матрица или вектор
    B : матрица, вектор или число
    elements : default=False, если нам необходимо поэлементное деление 
        элементов двух матриц на соответсвенных позициях установить значение True
    """
    rows_A = len(A)    # количество строк первой матрицы
    cols_A = len(A[0]) # количество столбцов первой матрицы

    # Если нам необходимо деление матрицы либо вектора на число
    # деление производится поэлементно
    if isinstance(B, (int, float)):
        scaler = B        
        result = [[A[row][col]*(1/scaler) for col in range(cols_A)] for row in range(rows_A)]
        return result
    else:        
        rows_B = len(B)     # количество строк второй матрицы
        cols_B = len(B[0])  # количество столбцов второй матрицы

        #Если нам необходимо поэлементное деление элементов двух матриц на соответсвенных позициях
        if elements:
            if rows_A == rows_B and cols_A == cols_B:
                result = [[A[row][col] / B[row][col] for col in range(cols_A)] 
                          for row in range(rows_A)]
                return result
            else:
                print("Невозможно поделить объекты. Разная размерность.")
                return

        # Если мы производим деление матриц друг на друга:
        # Необходимо умножить первую матрицу на матрицу, обратную второй матрице.
        # Необходимо проверить является ли вторая матрица квадратной.
        if not is_square(B):
            print("Вторая матрица не является квадратной.",
                  "Обратную матрицу можно найти только для квадратной матрицы",
                  "Деление матриц произвести невозможно.",
                  sep="\n")
            return
        # Необходимо проверить является ли вторая матрица невырожденной.
        if is_singular(B):
            print("Определитель второй матрицы равен 0.",
                  "Матрица является вырожденной.",
                  "Обратную матрицу можно найти только для невырожденной квадратной матрицы.",
                  "Деление матриц произвести невозможно.",
                  sep="\n")
            return
        
        # Инвертируем вторую матрицу
        inverse_B = inverse(B)

        # Количество столбцов первой матрицы должно быть равно 
        # количеству строк второй матрицы
        rows_B_inv = len(inverse_B)    # количество строк втрой обратной матрицы
        cols_B_inv = len(inverse_B[0]) # количество столбцов второй обратной матрицы     
        
        if cols_A == rows_B_inv:
            tmp = []
            result = []
            for row in range(rows_A):
                for col in range(cols_B_inv):
                    summ = 0
                    for k in range(rows_B_inv):
                        summ = summ + (A[row][k] * inverse_B[k][col])
                    tmp.append(summ)
                result.append(tmp)
                tmp = []
            return result
        else:
            print("Невозможно поделить объекты. Разная размерность.")
            return